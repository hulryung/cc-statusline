import { StatuslineConfig } from '../cli/prompts.js'
import { generateColorBashCode, generateBasicColors } from '../features/colors.js'
import { generateGitBashCode, generateGitDisplayCode, generateGitUtilities } from '../features/git.js'
import { generateUsageBashCode, generateUsageDisplayCode, generateUsageUtilities } from '../features/usage.js'

// Version will be updated when releasing
const VERSION = '1.4.0'

export function generateBashStatusline(config: StatuslineConfig): string {
  const hasGit = config.features.includes('git')
  const hasUsage = config.features.some(f => ['usage', 'session', 'tokens', 'burnrate'].includes(f))
  const hasDirectory = config.features.includes('directory')
  const hasModel = config.features.includes('model')
  const hasContext = config.features.includes('context')

  // Build usage feature config
  const usageConfig = {
    enabled: hasUsage && config.ccusageIntegration,
    showCost: config.features.includes('usage'),
    showTokens: config.features.includes('tokens'),
    showBurnRate: config.features.includes('burnrate'),
    showSession: config.features.includes('session')
  }

  // Build git feature config
  const gitConfig = {
    enabled: hasGit,
    showBranch: hasGit,
    showChanges: false, // Removed delta changes per user request
    compactMode: config.theme === 'compact'
  }

  const timestamp = new Date().toISOString()
  const script = `#!/bin/bash
# Generated by cc-statusline v${VERSION} (https://www.npmjs.com/package/@chongdashu/cc-statusline)
# Custom Claude Code statusline - Created: ${timestamp}
# Theme: ${config.theme} | Colors: ${config.colors} | Features: ${config.features.join(', ')}
STATUSLINE_VERSION="${VERSION}"

input=$(cat)

# ---- check jq availability ----
HAS_JQ=0
if command -v jq >/dev/null 2>&1; then
  HAS_JQ=1
fi
${config.logging ? generateLoggingCode() : ''}
${generateColorBashCode({ enabled: config.colors, theme: config.theme })}
${config.colors ? generateBasicColors() : ''}
${hasUsage ? generateUsageUtilities() : ''}
${hasGit ? generateGitUtilities() : ''}
${generateBasicDataExtraction(hasDirectory, hasModel, hasContext)}
${hasGit ? generateGitBashCode(gitConfig, config.colors) : ''}
${hasContext ? generateContextBashCode(config.colors) : ''}
${hasUsage ? generateUsageBashCode(usageConfig, config.colors) : ''}
${config.logging ? generateLoggingOutput() : ''}
${generateDisplaySection(config, gitConfig, usageConfig)}
`

  return script.replace(/\n\n\n+/g, '\n\n').trim() + '\n'
}

function generateLoggingCode(): string {
  return `
# Get the directory where this statusline script is located
SCRIPT_DIR="$(cd "$(dirname "\${BASH_SOURCE[0]}")" && pwd)"
LOG_FILE="\${SCRIPT_DIR}/statusline.log"
TIMESTAMP=$(date '+%Y-%m-%d %H:%M:%S')

# ---- logging ----
{
  echo "[$TIMESTAMP] Status line triggered (cc-statusline v\${STATUSLINE_VERSION})"
  echo "[$TIMESTAMP] Input:"
  if [ "$HAS_JQ" -eq 1 ]; then
    echo "$input" | jq . 2>/dev/null || echo "$input"
    echo "[$TIMESTAMP] Using jq for JSON parsing"
  else
    echo "$input"
    echo "[$TIMESTAMP] WARNING: jq not found, using bash fallback for JSON parsing"
  fi
  echo "---"
} >> "$LOG_FILE" 2>/dev/null
`
}

function generateJsonExtractorCode(): string {
  return `
# ---- JSON extraction utilities ----
# Pure bash JSON value extractor (fallback when jq not available)
extract_json_string() {
  local json="$1"
  local key="$2"
  local default="\${3:-}"
  
  # For nested keys like workspace.current_dir, get the last part
  local field="\${key##*.}"
  field="\${field%% *}"  # Remove any jq operators
  
  # Try to extract string value (quoted)
  local value=$(echo "$json" | grep -o "\\"\\$\{field}\\"[[:space:]]*:[[:space:]]*\\"[^\\"]*\\"" | head -1 | sed 's/.*:[[:space:]]*"\\([^"]*\\)".*/\\1/')
  
  # Convert escaped backslashes to forward slashes for Windows paths
  if [ -n "$value" ]; then
    value=$(echo "$value" | sed 's/\\\\\\\\/\\//g')
  fi
  
  # If no string value found, try to extract number value (unquoted)
  if [ -z "$value" ] || [ "$value" = "null" ]; then
    value=$(echo "$json" | grep -o "\\"\\$\{field}\\"[[:space:]]*:[[:space:]]*[0-9.]\\+" | head -1 | sed 's/.*:[[:space:]]*\\([0-9.]\\+\\).*/\\1/')
  fi
  
  # Return value or default
  if [ -n "$value" ] && [ "$value" != "null" ]; then
    echo "$value"
  else
    echo "$default"
  fi
}
`
}

function generateBasicDataExtraction(hasDirectory: boolean, hasModel: boolean, hasContext: boolean): string {
  return `
${generateJsonExtractorCode()}
# ---- basics ----
if [ "$HAS_JQ" -eq 1 ]; then${hasDirectory ? `
  current_dir=$(echo "$input" | jq -r '.workspace.current_dir // .cwd // "unknown"' 2>/dev/null | sed "s|^$HOME|~|g")` : ''}${hasModel ? `
  model_name=$(echo "$input" | jq -r '.model.display_name // "Claude"' 2>/dev/null)
  model_version=$(echo "$input" | jq -r '.model.version // ""' 2>/dev/null)` : ''}${hasContext ? `
  session_id=$(echo "$input" | jq -r '.session_id // ""' 2>/dev/null)` : ''}
  cc_version=$(echo "$input" | jq -r '.version // ""' 2>/dev/null)
  output_style=$(echo "$input" | jq -r '.output_style.name // ""' 2>/dev/null)
else${hasDirectory ? `
  # Bash fallback for JSON extraction
  # Extract current_dir from workspace object - look for the pattern workspace":{"current_dir":"..."}
  current_dir=$(echo "$input" | grep -o '"workspace"[[:space:]]*:[[:space:]]*{[^}]*"current_dir"[[:space:]]*:[[:space:]]*"[^"]*"' | sed 's/.*"current_dir"[[:space:]]*:[[:space:]]*"\\([^"]*\\)".*/\\1/' | sed 's/\\\\\\\\/\\//g')
  
  # Fall back to cwd if workspace extraction failed
  if [ -z "$current_dir" ] || [ "$current_dir" = "null" ]; then
    current_dir=$(echo "$input" | grep -o '"cwd"[[:space:]]*:[[:space:]]*"[^"]*"' | sed 's/.*"cwd"[[:space:]]*:[[:space:]]*"\\([^"]*\\)".*/\\1/' | sed 's/\\\\\\\\/\\//g')
  fi
  
  # Fallback to unknown if all extraction failed
  [ -z "$current_dir" ] && current_dir="unknown"
  current_dir=$(echo "$current_dir" | sed "s|^$HOME|~|g")` : ''}${hasModel ? `
  
  # Extract model name from nested model object
  model_name=$(echo "$input" | grep -o '"model"[[:space:]]*:[[:space:]]*{[^}]*"display_name"[[:space:]]*:[[:space:]]*"[^"]*"' | sed 's/.*"display_name"[[:space:]]*:[[:space:]]*"\\([^"]*\\)".*/\\1/')
  [ -z "$model_name" ] && model_name="Claude"
  # Model version is in the model ID, not a separate field  
  model_version=""  # Not available in Claude Code JSON` : ''}${hasContext ? `
  session_id=$(extract_json_string "$input" "session_id" "")` : ''}
  # CC version is at the root level
  cc_version=$(echo "$input" | grep -o '"version"[[:space:]]*:[[:space:]]*"[^"]*"' | head -1 | sed 's/.*"version"[[:space:]]*:[[:space:]]*"\\([^"]*\\)".*/\\1/')
  # Output style is nested
  output_style=$(echo "$input" | grep -o '"output_style"[[:space:]]*:[[:space:]]*{[^}]*"name"[[:space:]]*:[[:space:]]*"[^"]*"' | sed 's/.*"name"[[:space:]]*:[[:space:]]*"\\([^"]*\\)".*/\\1/')
fi
`
}

function generateContextBashCode(colors: boolean): string {
  return `
# ---- context window calculation (native) ----
context_pct=""
context_remaining_pct=""
context_color() { if [ "$use_color" -eq 1 ]; then printf '\\033[1;37m'; fi; }  # default white

if [ "$HAS_JQ" -eq 1 ]; then
  # Get context window size and current usage from native Claude Code input
  CONTEXT_SIZE=$(echo "$input" | jq -r '.context_window.context_window_size // 200000' 2>/dev/null)
  USAGE=$(echo "$input" | jq '.context_window.current_usage' 2>/dev/null)

  if [ "$USAGE" != "null" ] && [ -n "$USAGE" ]; then
    # Calculate current context from current_usage fields
    # Formula: input_tokens + cache_creation_input_tokens + cache_read_input_tokens
    CURRENT_TOKENS=$(echo "$USAGE" | jq '(.input_tokens // 0) + (.cache_creation_input_tokens // 0) + (.cache_read_input_tokens // 0)' 2>/dev/null)

    if [ -n "$CURRENT_TOKENS" ] && [ "$CURRENT_TOKENS" -gt 0 ] 2>/dev/null; then
      context_used_pct=$(( CURRENT_TOKENS * 100 / CONTEXT_SIZE ))
      context_remaining_pct=$(( 100 - context_used_pct ))
      # Clamp to valid range
      (( context_remaining_pct < 0 )) && context_remaining_pct=0
      (( context_remaining_pct > 100 )) && context_remaining_pct=100

      # Set color based on remaining percentage
      if [ "$context_remaining_pct" -le 20 ]; then
        context_color() { if [ "$use_color" -eq 1 ]; then printf '\\033[38;5;203m'; fi; }  # coral red
      elif [ "$context_remaining_pct" -le 40 ]; then
        context_color() { if [ "$use_color" -eq 1 ]; then printf '\\033[38;5;215m'; fi; }  # peach
      else
        context_color() { if [ "$use_color" -eq 1 ]; then printf '\\033[38;5;158m'; fi; }  # mint green
      fi

      context_pct="\${context_remaining_pct}%"
    fi
  fi
fi
`
}

function generateLoggingOutput(): string {
  return `
# ---- log extracted data ----
{
  echo "[\$TIMESTAMP] Extracted: dir=\${current_dir:-}, model=\${model_name:-}, version=\${model_version:-}, git=\${git_branch:-}, context=\${context_pct:-}, cost=\${cost_usd:-}, cost_ph=\${cost_per_hour:-}, tokens=\${tot_tokens:-}, tpm=\${tpm:-}, session_pct=\${session_pct:-}"
  if [ "$HAS_JQ" -eq 0 ]; then
    echo "[\$TIMESTAMP] Note: Context, tokens, and session info require jq for full functionality"
  fi
} >> "$LOG_FILE" 2>/dev/null
`
}

function generateDisplaySection(config: StatuslineConfig, gitConfig: any, usageConfig: any): string {
  const emojis = config.colors && !config.customEmojis

  return `
# ---- render statusline ----
# Line 1: Core info (directory, git, model, claude code version, output style)
${config.features.includes('directory') ? `printf 'ğŸ“ %s%s%s' "$(dir_color)" "$current_dir" "$(rst)"` : ''}${gitConfig.enabled ? `
if [ -n "$git_branch" ]; then
  printf '  ğŸŒ¿ %s%s%s' "$(git_color)" "$git_branch" "$(rst)"
fi` : ''}${config.features.includes('model') ? `
printf '  ğŸ¤– %s%s%s' "$(model_color)" "$model_name" "$(rst)"
if [ -n "$model_version" ] && [ "$model_version" != "null" ]; then
  printf '  ğŸ·ï¸ %s%s%s' "$(version_color)" "$model_version" "$(rst)"
fi` : ''}
if [ -n "$cc_version" ] && [ "$cc_version" != "null" ]; then
  printf '  ğŸ“Ÿ %sv%s%s' "$(cc_version_color)" "$cc_version" "$(rst)"
fi
if [ -n "$output_style" ] && [ "$output_style" != "null" ]; then
  printf '  ğŸ¨ %s%s%s' "$(style_color)" "$output_style" "$(rst)"
fi

# Line 2: Context and session time
line2=""${config.features.includes('context') ? `
if [ -n "$context_pct" ]; then
  line2="ğŸ§  $(context_color)Context Remaining: \${context_pct}$(rst)"
fi` : ''}${usageConfig.showSession ? `
if [ -n "$session_txt" ]; then
  if [ -n "$line2" ]; then
    line2="$line2  âŒ› $(session_color)\${session_txt}$(rst)"
  else
    line2="âŒ› $(session_color)\${session_txt}$(rst)"
  fi
fi` : ''}${config.features.includes('context') ? `
if [ -z "$line2" ] && [ -z "$context_pct" ]; then
  line2="ğŸ§  $(context_color)Context Remaining: TBD$(rst)"
fi` : ''}

# Line 3: Cost and usage analytics
line3=""${usageConfig.showCost ? `
if [ -n "$cost_usd" ] && [[ "$cost_usd" =~ ^[0-9.]+$ ]]; then${usageConfig.showBurnRate ? `
  if [ -n "$cost_per_hour" ] && [[ "$cost_per_hour" =~ ^[0-9.]+$ ]]; then
    cost_per_hour_formatted=$(printf '%.2f' "$cost_per_hour")
    line3="ğŸ’° $(cost_color)\\$$(printf '%.2f' "$cost_usd")$(rst) ($(burn_color)\\$\${cost_per_hour_formatted}/h$(rst))"
  else
    line3="ğŸ’° $(cost_color)\\$$(printf '%.2f' "$cost_usd")$(rst)"
  fi` : `
  line3="ğŸ’° $(cost_color)\\$$(printf '%.2f' "$cost_usd")$(rst)"`}
fi` : ''}${usageConfig.showTokens ? `
if [ -n "$tot_tokens" ] && [[ "$tot_tokens" =~ ^[0-9]+$ ]]; then${usageConfig.showBurnRate ? `
  if [ -n "$tpm" ] && [[ "$tpm" =~ ^[0-9.]+$ ]]; then
    tpm_formatted=$(printf '%.0f' "$tpm")
    if [ -n "$line3" ]; then
      line3="$line3  ğŸ“Š $(usage_color)\${tot_tokens} tok (\${tpm_formatted} tpm)$(rst)"
    else
      line3="ğŸ“Š $(usage_color)\${tot_tokens} tok (\${tpm_formatted} tpm)$(rst)"
    fi
  else
    if [ -n "$line3" ]; then
      line3="$line3  ğŸ“Š $(usage_color)\${tot_tokens} tok$(rst)"
    else
      line3="ğŸ“Š $(usage_color)\${tot_tokens} tok$(rst)"
    fi
  fi` : `
  if [ -n "$line3" ]; then
    line3="$line3  ğŸ“Š $(usage_color)\${tot_tokens} tok$(rst)"
  else
    line3="ğŸ“Š $(usage_color)\${tot_tokens} tok$(rst)"
  fi`}
fi` : ''}

# Print lines
if [ -n "$line2" ]; then
  printf '\\n%s' "$line2"
fi
if [ -n "$line3" ]; then
  printf '\\n%s' "$line3"
fi
printf '\\n'`
}